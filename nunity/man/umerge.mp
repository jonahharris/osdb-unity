.\"
.\" Copyright (C) 2002-2003 by Lucent Technologies
.\"
.TH umerge 1 "" "New UNITY"
.SA 1
.SH NAME
umerge \- merge new tuples in a UNITY relation
.SH SYNOPSIS
.HP
.B umerge
[-cEinPqRsuUVz]
[-d\fI<delim>\fR]
[-P\fI<ExitCode>\fR] \e
.br
[-M {blanks|caseless}]
[-Q [\fI<ErrorLimit>\fR]] \e
.br
[{-e|-m} \fI<RecordCount>\fR]
[-r[{K|M|Q}#]\fI<RecordLimit>\fR] \e
.br
[-f[REC#]\fI<precision>\fR]
[-f[{K|M|Q|r|s}#]\fI<precision>\fR] \e
.br
[\fI<attr>\fR[:\fI<modifiers>\fR...] [as \fI<newattr>\fR] ...] \e
.br
[{keyed|sorted}\ [by\ \fI<attr>\fR[:\fI<modifiers>\fR]\ ...\ [ALL]]]\ \e
from\ \fI<table>\fR[=\fI<alt_table>\fR]...\ in\ \fI<table>\fR[=\fI<alt_table>\fR]\ \e
[{keyed|sorted}\ [by\ {\fI<attr>\fR[:\fI<modifiers>\fR]\ ...\ |\ rec#\ \fI<recnum>\fR}]]\ \e
[where \fI<where-clause>\fR]
.SH DESCRIPTION
.B umerge
is a command for merging new tuples (records) into an
existing UNITY table that is to be maintained in a given sort order.
This command is equivalent to a retrieve(1) onto the relation
followed by a usort(1) to restore the records to keyed (sort) order.
.B umerge
can also delete retrieved tuples that have
non-unique key attributes (i.e., uniqueness based on a subset
of the attributes for each tuple) and it can replace existing
tuples when the keys match.
.P
By default the new tuples are merged in the output table
using a lexical comparison of all attributes
in the order in which they appear in the output table.
The "sorted by" or (keyed by) clause after the "in <table>"
clause can be used to specify which attributes
and the order to be used for comparing tuples.
The optional attribute modifiers can be used to change
the type of comparison (e.g., date, lexical, numeric, etc.)
as well as ascending or descending sort order for each
attribute.
The first attribute in the "by" clause is sorted first
(highest priority) followed by the next attribute
and so on.
.P
In order to prevent duplicate records in the output table
the upper case -U (Unique) option should be used which
is equivalent to using "keyed by ALL".
If the "keyed by" clause is used to compare new tuples
to be merged then only the specified attributes are
used to check for uniqueness and sort order.
When comparing an existing tuple to a new tuple
using "key" attributes, the existing tuple is preserved
in the output table and the new tuple is discarded
unless the -R (replace) option is given.
When using the replace option and the key attributes
match, then the existing tuple is discarded and the
new tuple replaces it in the output table.
It should be noted that when comparing tuples using
key attributes and the attribute values match,
one tuple gets written to the (updated) output table
and the other gets discarded and then a new pair of
tuples is read, one from the existing output table
and the other from the set of tuples generated by
the input table query.
If the next new tuple returned by the query has
the same key attribute values as the previous
tuple that was retrieved from the query,
then the tuple with non-unique key attribute
values will end up in the updated output table.
Therefore, the user should consider adding the
lower case -u (unique) option and/or the "keyed by"
clause that appears before the "from <table(s)>"
clause on the command line, if needed,
to make sure that all tuples retrieved from
the query have key attribute values.
The upper case -U option is ignored when merging tuples
with the "keyed by" clause or when using "rec# <recnum>"
as either the key (key by) or sort (sort by) attribute.
.P
The replace (-R) option can also be used with the
"sorted by" clause to indicate that the new
tuple to is to replace the position of the
existing tuple in the output table when
comparing an existing tuple with a new tuple
and the attribute values match.
In this case, the existing tuple is not discarded
but is added to the new (updated) output table
after the new tuple(s) that have matching (sort by)
attribute values.
.P
The "keyed by rec# <recnum>" or "sorted by rec# <recnum>"
clause is used to indicate that the new tuples are to
be merged into the the output table starting at the
given record number (<recnum>) in the output table.
If there are less than \fI<recnum>\fR minus one (1)
records in the current output table,
then umerge will print an error message indicating
that it cannot seek to the given record position
and return an exit status code of six (6).
When using "sorted by rec# <recnum>",
all new tuples are merged into the output table
immediately after (or immediately before when
using the -R option) the given record number
in the output table.
When using "keyed by rec# <recnum>",
starting with the given record number
in the output table,
the next existing tuple in the output table
is compared to the next new tuple retrieved
from the query.
For each pair of tuples compared,
one tuple will be written to the updated
output table and the other tuple discarded.
If there is no existing tuple in the output
table to compare to the next new tuple then,
by default, the new tuple is written to the
updated output file.
.P
A "keyed by" clause can be used in place of or in addition to
the existing "sorted by" clause that appears before
the "from <table(s)>" clause on the command line.
If both are used then the "keyed by" clause must
appear before the "sorted by" clause that precedes
the "from <table>" clause.
When the "keyed by" clause is used,
umerge will compare each adjacent pair of tuples
retrieved by the query for having unique key
attribute values.  If the next tuple retrieved
from the query has the same key attribute values
as the previous retrieved tuple then the tuple
is discarded.  Both the "keyed by" and the "sorted by"
list (if specified) are using during the query (tuple
retrieval) phase to sort the new tuples before
checking each adjacent pair of tuples for unique key
attribute values.
It should be noted that attributes which are not
projected or have beed modified to be "nodisplay"
cannot be used in a list of "keyed by" attributes.
.P
If the keyword "keyed" or "sorted" is used
without a "by" attribute list after the
"in <table>" clause then the list of
"keyed by" or "sorted by" attributes
used to sort the retrieved tuples is
also used to compare the tuples to be
merged into the output table.
If no "keyed by" or "sorted by" clause
is used for sorting or checking uniqueness
of retrieved tuples then all attribute
values are used for sorting and checking
uniqueness of new tuples to be merged
into the output table.
If both "keyed by" and "sorted by" clauses
are used to retrieve new tuples and no
"by" attribute list is given for comparing
tuples to be merged,
then only the key attributes will be used
as the list of attributes for
comparing tuples to be merged (sorted or keyed)
into the output table.
.P
The keyword "into" or "onto" can be used
in place of the keyword "in" in the "in <table>"
clause to get normal UNITY operation of
either creating a new table with the new tuples
or appending the new tuples to the end
of an existing table.
A "keyed" or "sorted" (by) clause cannot be used
after either the "into <table>" or "onto <table>"
clause since no comparisons are to be done between
the new tuples and the existing tuples in the output table.
It should be noted that the output table is always locked
regardless of whether new tuples are to merged with
existing tuples or the new tuples are added to the
end of the existing (or newly created) output table.
.P
Attributes can be sorted in more than one way (e.g.,
numeric and lexical) by including the attribute
more than once in the keyed or sorted "by" clause.
It should be noted that uniqueness checks are
based on the sort comparison type(s).
If more than one type of comparison is specified
for a given attribute then uniqueness for that
attribute is based on each type of comparison specified.
.P
The where-clause is used by the query to select
which records from the input table(s) are to be
retrieved as new tuples to be merged into the
output table.
The where-clause is not used to merge the
retrieved tuples into the the output table.
.P
By default the descriptor file for a table is named \f(CWD\fI<table>\fR.
A descriptor file from another table can be specified by adding
``=\fI<alt_table>\fR'' after the table name.
The alternate descriptor file will be \f(CWD\fI<alt_table>\fR.
Note that if \fI<alt_table>\fR contains a path,
the given directory will be checked first for the alternate
descriptor file.
The \fIUNITYDFILES\fR and \fIUNITYDSEARCH\fR entries in the \fBENVIRONMENT\fR
section describe how the descriptor information for a table is located.
.SH SPECIAL PSEUDO ATTRIBUTES
.TP
.B ALL
The special ``ALL'' attribute can be used,
if it has not be defined as a normal attribute
or when qualified as ``ALL:nodisplay='' to indicate that all attributes,
which have not been specified previously, should
also be sorted in the order in which they appear
in the table along with any modifiers given to
the special ``ALL'' attribute.
.TP
.B all
The special ``all'' attribute is used by
UNITY to refer to all normal attributes
for a given table when ``all'' has not been
defined as a normal attribute or when qualified
as ``all:nodisplay=''.
Since more than one input table can be used
to retrieve new tuples to be merged,
the special attribute ``ALL'' should be
used instead of ``all'' in a keyed and/or
sorted by clause to indicate that all projected
attributes, which have not been specified previously,
should also be included.
.TP
.B REC#
The pseudo attribute ``\fIREC#\fR''
refers to the output table record number
where the new tuple will appear when it
is/has been merged.
It can only be used with the "as\ \fI<attr>\fR" clause
to rename it as a projected attribute.
It cannot be used for sorting tuples.
.TP
.B rec#
The special attribute ``\fIrec#\fR''
(the record number of the tuple in the table)
can be used for sorting retrieved tuples
in addition to the normal table attributes
and/or it can be renamed as a projected attribute
using the "as\ \fI<attr>\fR" clause.
It can also be used as the one and only
attribute to be used for merging tuples
into the output table.
However, it can never be used with
other normal attributes for merging
tuples into the output table.
.TP
.B recM#
The pseudo attribute ``\fIrecM#\fR''
refers to the record number of the
new tuple that is being merged into
the output table.
It has a starting value of one (1)
that is incremented each time a new
tuple has been merged into the output table.
It can only be used with the "as\ \fI<attr>\fR" clause
to rename it as a projected attribute.
It cannot be used for sorting tuples.
.TP
.B recK#
The pseudo attribute ``\fIrecK#\fR''
refers to the record number of the
new tuple that has been retrieved
from the query and has unique key
attribute values.
It has a starting value of one (1)
that is incremented each time a new
tuple tuple is retrieved from the
query which has unique key attribute
values compared to the previous tuple
that was retrieved from the query.
It can only be used with the "as\ \fI<attr>\fR" clause
to rename it as a projected attribute.
It cannot be used for sorting tuples.
It should be noted that
``\fIrecK#\fR'' will always contain
a value that is greater than or equal to
the value of ``\fIrecM#\fR''.
.TP
.B recQ#
The pseudo attribute ``\fIrecQ#\fR''
refers to the record number of the
new tuple that has been retrieved
from the query before checking
key attribute values for uniqueness,
if specified.
It has a starting value of one (1)
that is incremented each time a new
tuple tuple is retrieved from the
query.
It can only be used with the "as\ \fI<attr>\fR" clause
to rename it as a projected attribute.
It cannot be used for sorting tuples.
It should be noted that
``\fIrecQ#\fR'' will always contain
a value that is greater than or equal to
the value of ``\fIrecK#\fR''.
If no "key" attributes are specified,
then ``\fIrecQ#\fR'' and ``\fIrecK#\fR''
will always have the same value.
.TP
.B seek#
The special attribute ``\fIseek#\fR''
(the seek location of the start of the tuple
within the table)
can be used for sorting retrieved tuples
in addition to the normal table attributes
and/or it can be renamed as a projected attribute
using the "as\ \fI<attr>\fR" clause.
It can never be used for merging tuples
into the output table.
.SH PARAMETERS
.TP
.B -c
Create descriptor file in output directory if table
does not already exist.
If descriptor file already
exists in the output directory and "into <table>"
was specified then umerge will terminate (abort)
and return a non-zero status code.
.TP
.BI -d c [!]\ [-d o ]
Use the character \fIc\fR as the delimiter between all attribute
values in the output or in place of the old delimiter character(s) \fIo\fR.
To change fixed width attributes to be terminated by the character \fIc\fR,
the (second) -d option can be used without the \fIo\fR character(s).
Any number of -d\fIo\fR options can be given and/or a string of \fIo\fR characters
given.  Any standard C backslash escape sequences will be converted to
their character equivalents (i.e., "\e0" == '\e0').
If an old delimiter character \fIo\fR is specified and the new delimiter
character \fIc\fR is followed by the '!' (not) character,
then the character \fIc\fR will be used as the new delimiter character
where \fIo\fR is not the current delimiter (or fixed width attribute).
It should be noted that using this option has no effect if the
output table or the output table descriptor already exists.
.TP
.B -E
Exit with status code four (4) and do not update table
when either using merge keyed by clause and the target tuple(s)
exist in the output table and the -R (replace) option
was not given or
when using merge keyed by clause and the target tuple(s)
do not exist in the output table and the -R option
was given.
.TP
.BI -e <RecordCount>
Exactly \fI<RecordCount>\fR record(s) are to be merged.
If number of tuples that are merged is not equal to
\fI<RecordCount>\fR then umerge will abort the update
and exit with status code five (5).
.TP
.BI -F \fR[REC#]\fP<precision>
Print pseudo attribute ``REC#'' with a precision
of \fI<precision>\fR digits where \fI<precision>\fR
must be a number between 1 and 10, inclusive.
If the number being printed requires less
than \fI<precision>\fR digits, it is padded with leading
zeros so that printed output number
contains at least \fI<precision>\fR digits.
Use of the leading "REC#" before \fI<precision>\fR
is optional.
.TP
.BI -f \fR[{K|M|Q|r|s}#]\fP<precision>
Print attribute ``recK#'' or ``recM#''
or \\recQ#'' or ``rec#'' or ``seek#'' with a precision
of \fI<precision>\fR digits where \fI<precision>\fR
must be a number between 1 and 10, inclusive.
If the number being printed requires less
than \fI<precision>\fR digits, it is padded with leading
zeros so that printed output number
contains at least \fI<precision>\fR digits.
If \fI<precision>\fR is not prefixed by "{K|M|Q|r|s}#",
then all five attributes recK#, recM#, recQ#, rec#, and seek#
will be printed with the given precision.
.TP
.B -i
Ignore case of attribute values when doing
tuple comparisons in the where-clause.
.TP
.B -M { blanks | caseless }
Ignore blanks or character case, respectively, for all attributes
that are to be used for sorting as appropriate.
This is a short-hand way to avoid having to include the
"blanks" or "caseless" modifier with each individual attribute.
This modifier is not added to attributes which are not to be sorted
or are being sorted by a non-lexical type of comparison operator
(e.g., date, numeric, etc.).
.TP
.BI -m <RecordCount>
At most \fI<RecordCount>\fR record(s) are to be merged.
If number of tuples that are merged is greater than
\fI<RecordCount>\fR then umerge will abort the update
and exit with status code five (5).
.TP
.B -n
No-change mode.
This option is used to see what
.B umerge
would do without making any updates to the output table.
.TP
.BI -P <ExitCode>
Do not print error messages when umerge terminates
with exit code \fI<ExitCode>\fR which must be
four (4), five (5), or six (6).
See the EXIT CODES section for an explanation of each
of these error codes.
.TP
.BI -Q " [<ErrorLimit>]"
Gracefully continue after encountering any tuple syntax errors instead of quitting.
An error limit can be specified with this option (i.e., "-Q \fIErrorLimit\fP")
to limit the number of tuple syntax error (warning) messages that would otherwise
be printed when there are many tuples that (might) have syntax errors.
An error limit of minus one (-1) can be used to indicate that
a warning message for each tuple error is to be printed.
If no error limit or an error limit of zero (0) is given,
only a summary message with the total number of tuples with tuple errors
for all relations that were queried will be printed.
The tuple error summary message is not printed if there were no tuple errors or
if the -q (quiet mode) option was specified.
.TP
.B -q
Operate in quiet mode.
Normally,
.B umerge
prints the number of records merged on standard error.
If this option is given, this message is suppressed.
.TP
.B -R
Replace record (keyed) or record position (sorted)
when comparison of existing tuple and new tuple
match.
Default (without -R option) is to keep
existing tuples with matching keys (keyed) or merge
retrieved tuples after existing tuples that match
sort order (sorted).
.TP
.B -r[{K|M|Q}#]\fI<RecordLimit>\fP
Limit the number of records retrieved to \fIRecordLimit\fP.
If \fI<RecordLimit>\fP is prefixed by "K#", "M#", or "Q#",
then no new tuples will be retrieved from the input query
after the specified record limit for the pseudo attribute
recK#, recM#, or recQ#, respectively, has been reached.
Otherwise, no new tuples are retrieved from the input query
after the specified record limit for any of these three
pseudo attributes has been reached.
.TP
.B -s
Sort the new tuples that are retrieved from the query.
.TP
.B -U
Unique tuples in the output table.
Do not merge tuples in the output table that are not unique
based on all tuple attributes.
This option is ignored when merging tuples based
on "key" (keyed by) attributes or record number (rec#).
.TP
.B -u
Only retrieve unique tuples from the input query.
Duplicate (identical) tuples are determined
by the type of sort comparison operator(s)
used for each individual attribute which
do not have to include a lexical
(character-by-character) comparison.
.TP
.B -V
Print the version of the command and exit.
No sorting is done.
.TP
.B -z
Do not include zero-width attributes 
or attributes with upper case justification (C, L, or R) when no
projected attributes are listed or when
the special ``all'' attribute is expanded.
.SH ATTRIBUTE MODIFIERS
.P
Attribute
.I <modifiers>
dictate special handling for the given attribute.
Any number of modifiers can be given for an attribute but
each must begin with a colon (``:'').
The modifiers can be separated by white space or
can immediately follow each other.
Most attribute modifiers can be abbreviated (truncated)
to the first few unique characters in the modifier keyword.
Below are the recognized attribute modifiers that impact sorting:
.RS .5i
.TP
.B :ascending
Sort the attribute's values in ascending order.
This is the default sort order.
.TP
.B :binary
Use binary (base 2) unsigned integer comparison on this attribute
for sorting or uniqueness.
This comparison type is not valid with
the special ``rec#'' and ``seek#'' attributes.
.TP
.B :blanks
Remove all white space from the beginning of the attribute
and any sub-fields before doing the sort or determining uniqueness.
.TP
.B :caseless
Use a character-by-character comparison on this attribute for sorting or uniqueness
but ignore the case of letters.
.TP
.B :date
Use a date comparison on this attribute for sorting or uniqueness.
.TP
.B :descending
Sort the attribute's values in descending order.
Normally, attribute values are sorted in ascending order.
.TP
.B :dictionary
Use a character-by-character comparison on this attribute
for sorting or uniqueness, but ignore characters
which are not letters, digits, or blanks (spaces or tabs).
The "caseless" modifier can be used with this option to
also ignore the case of letters.
.TP
.BI :field <field#>\fR[.\fP<char#>\fR][\fP - <field#>\fR[.\fP<char#>\fR],...\fP
Use only the given sub-fields and/or character
positions in the attribute for sorting.
This option implies that records will be sorted;
sub-fields are not used when determining uniqueness.
Up to four sub-field ranges may be specified.
Any additional ranges are ignored.
Sub-field and character positions start at 1.
The ending field and character positions are inclusive.
The sub-fields are determined by the split string given
with the
.B :split
modifier.
The default split string is a comma.
.IP
If different sub-fields need different types of comparisons
(e.g., a number appended to a string),
the attribute and sub-fields can be listed multiple times,
each with the different comparison specification.
.TP
.B :hexadecimal
Use \fIh\fPexadecimal (base 16) unsigned integer comparison on this attribute
for sorting or uniqueness.
This comparison type is not valid with
the special ``rec#'' and ``seek#'' attributes.
.TP
.B :numeric
Use a numeric comparison on this attribute for sorting or uniqueness.
This is the default (and only supported) comparison type for
the special ``rec#'' and ``seek#'' attributes.
.TP
.B :octal
Use octal (base 8) unsigned integer comparison on this attribute
for sorting or uniqueness.
This comparison type is not valid with
the special ``rec#'' and ``seek#'' attributes.
.TP
.B :printable
Use a character-by-character comparison on this attribute
for sorting or uniqueness, but ignore characters
which are not printable (i.e., outside the ASCII range of 040-0176).
The "caseless" modifier can be used with this option to
also ignore the case of letters.
.TP
.BI :split <string>
Use the given
.I <string>
as the delimiters for splitting the attribute into sub-fields
for sorting.
(See the
.B :field
modifier for more information on sub-fields.)
Sub-fields are
.I not
used when determining uniqueness.
Unlike most modifiers, this modifier
.I "must not"
be abbreviated.
Everything after ``:split'' is used as the
split string.
The default split string is ``,''.
Each character in the split string is used to locate
the end of the respective sub-field in the attribute.
The last character in the split string is repeated as needed.
Thus, if five fields are separated by commas, ``:split,'' and ``:split,,,,''
are equivalent specifications.
If the first field were separated by a forward slash
and the rest by commas, the modifier would be ``:split/,''.
If a colon (``:'') is needed as one of the split characters,
it must be preceded by a backslash (``\e'') in order to not be
interpreted as the start of a new modifier.
Normal C-like escape sequences are also recognized in the
split string.
.TP
.B :string
Use a character-by-character
comparison on this attribute for sorting or uniqueness.
This is the default comparison type except the
special ``rec#'' and ``seek#'' attributes, which are always numeric.
.SH ENVIRONMENT
.so Environ.u.h
.so Envunpack.u.h
.SH EXIT CODES          \" strongly recommended
.TP 5
0
Normal termination.
.TP
1
Invocation error \- accompanied by explanatory message.
.TP
2
Execution error \- accompanied by explanatory message.
.TP
3
Abnormal termination \- command killed by signal.
.TP
.B 4
Termination due to use of the -E option and
merging of tuples based on key attributes
when either the tuple to be replaced (-R option was specified)
does not exist in the current output table or
the output table already contains a tuple with
the same key attribute values (-R option was not specified).
An error message is printed that identifies
the record number of the input tuple or existing output tuple
where key match (or no-match) error occurred.
This error message can be supressed by using the -P4 option.
.TP
.B 5
Termination due to use of either the -e (exactly) or -m (at most)
option when the number of tuples merged did not match (-e) or
exceeded (-m) the expected merged record count.
An error message is printed which includes the number of tuples
that would have been merged.
This error message can be supressed by using the -P5 option.
.TP
.B 6
Termination due to the number of records in the existing output
table being less than the number required to begin merging
tuples at a specified record number.
The error message that is printed,
which includes the number of records in the current output table,
can be supressed by using the -P6 option.
.SH RESTRICTIONS        \" optional - includes caveats and bugs
.so Restrict.h
.SH EXAMPLES
Merge all tuples from table ``odd.new'' into table ``odds''
using the default (lexical) sorting order:
.PP
.ne 8
.RS
.nf
.ft CW
$ uprint odd.new
|---------------------------------------------------|
|  lab  | oddname|   laboddid   |asn|     docdir    |
|---------------------------------------------------|
|INTL2  |TWw.BU2 |19990730135409| 0 |UPR2.1/TWw.BU2 |
|INTL3.0|TWw.BU3 |19990730135410| 1 |UPR2.1/TWw.BU3 |
|---------------------------------------------------|

.ft
.fi
.RE
.ne 8
.RS
.nf
.ft CW
$ uprint odds
|-------------------------------------------------------------|
|  lab  | oddname|   laboddid   |asn|     docdir    | oddinfo |
|-------------------------------------------------------------|
|INTL1  |TWw.BU1 |19990730135408| 0 |UPR2.1/TWw.BU1 |ex235d   |
|INTL3.1|TWw.BU4 |19990730135411| 0 |UPR2.1/TWw.BU4 |ex238d   |
|-------------------------------------------------------------|

.ft
.fi
.RE
.ne 11
.RS
.nf
.ft CW
$ umerge from odd.new in odds 
umerge: 2 records merged - 4 total
$ uprint odds
|-------------------------------------------------------------|
|  lab  | oddname|   laboddid   |asn|     docdir    | oddinfo |
|-------------------------------------------------------------|
|INTL1  |TWw.BU1 |19990730135408| 0 |UPR2.1/TWw.BU1 |ex235d   |
|INTL2  |TWw.BU2 |19990730135409| 0 |UPR2.1/TWw.BU2 |         |
|INTL3.0|TWw.BU3 |19990730135410| 1 |UPR2.1/TWw.BU3 |         |
|INTL3.1|TWw.BU4 |19990730135411| 0 |UPR2.1/TWw.BU4 |ex238d   |
|-------------------------------------------------------------|

.ft
.fi
.RE
The example above assumed that the tuples in the input table
were already in sorted order.  It should be noted that the
``oddinfo'' field for the two (2) tuples that were merged
have no value since there was no corresponding field from the
input table.
.PP
The next example builds on the previous one and
shows how the uniqueness (-u and -U) flags can be used to
prevent or not prevent duplicate tuples from
being merged into the output table when using the
default sort order and tuple uniqueness based on all attributes:
.PP
.ne 15
.RS
.nf
.ft CW
$ umerge -u -U from odd.new in odds
umerge: 0 records merged - 4 total
$ umerge -u from odd.new in odds
umerge: 2 records merged - 6 total
$ uprint odds
|-------------------------------------------------------------|
|  lab  | oddname|   laboddid   |asn|     docdir    | oddinfo |
|-------------------------------------------------------------|
|INTL1  |TWw.BU1 |19990730135408| 0 |UPR2.1/TWw.BU1 |ex235d   |
|INTL2  |TWw.BU2 |19990730135409| 0 |UPR2.1/TWw.BU2 |         |
|INTL2  |TWw.BU2 |19990730135409| 0 |UPR2.1/TWw.BU2 |         |
|INTL3.0|TWw.BU3 |19990730135410| 1 |UPR2.1/TWw.BU3 |         |
|INTL3.0|TWw.BU3 |19990730135410| 1 |UPR2.1/TWw.BU3 |         |
|INTL3.1|TWw.BU4 |19990730135411| 0 |UPR2.1/TWw.BU4 |ex238d   |
|-------------------------------------------------------------|
.ft
.fi
.RE
.PP
The next example shows two input tables being joined using a
where-clause to retrieve
the data to be merged into the output table which
is keyed (and sorted) by a subset of the attributes:
.RS
.nf
.ft CW
.PP
$ uprint -e odd_info
     |---------------------------------|
     |   laboddid   |    oddinfo   |asn|
     |---------------------------------|
   1 |19990740135408|5ee12,1.p5.1  |1  |
   2 |19990740135411|5ee12,1.p3.0  |2  |
   3 |19990740135411|5ee12,1.p3.0  |3  |
     |---------------------------------|

$ uprint -e odd_ids
     |-----------------------|
     | oddname|   laboddid   |
     |-----------------------|
   1 |TWw.BU2 |19990740135408|
   2 |TWw.BU6 |19990740135411|
     |-----------------------|

$ uprint -e odds
     |--------------------------------------------------|
     |  lab  | oddname|   laboddid   |asn|    oddinfo   |
     |--------------------------------------------------|
   1 |INTL1  |TWw.BU1 |19990730135408| 0 |5ee12,1.p5.1  |
   2 |INTL3.1|TWw.BU4 |19990730135411| 0 |5ee12,1.p3.0  |
     |--------------------------------------------------|

$ umerge 1.oddname 1.oddname:value=INTL2 as lab 2.all \e
> keyed by oddname \e
> sorted by 2.laboddid:numeric:descend 2.asn:numeric:descend \e
> from odd_ids odd_info in odds keyed by lab oddname \e
> where 1.laboddid f= 2.laboddid
umerge: 2 records merged - 4 total
$ uprint -e odds 
     |--------------------------------------------------|
     |  lab  | oddname|   laboddid   |asn|    oddinfo   |
     |--------------------------------------------------|
   1 |INTL1  |TWw.BU1 |19990730135408| 0 |5ee12,1.p5.1  |
   2 |INTL2  |TWw.BU2 |19990740135408| 1 |5ee12,1.p5.1  |
   3 |INTL2  |TWw.BU6 |19990740135411| 3 |5ee12,1.p3.0  |
   4 |INTL3.1|TWw.BU4 |19990730135411| 0 |5ee12,1.p3.0  |
     |--------------------------------------------------|
.ft
.fi
.RE
.PP
It should be noted in the example above that the original
``odd_info'' table contained two tuples with the same key
values which is why the "keyed by" clause after the list
of attributes was needed to prevent both from being merged.
Using the (lower case) uniquness (-u) option would not
have prevented both tuples with same key values from
being merged since they had different ``asn'' values.
.PP
This last example demonstrates the use of each of the
pseudo record number attributes and how their values
differ:
.br
.ne 37
.RS
.nf
.ft CW
$ uprint -e input
     |---------------------------------|
     |seq|   fname  |   lname  |  key  |
     | no|          |          |       |
     |---------------------------------|
   1 |1  |Joe       |Smith     |555    |
   2 |2  |John      |Doe       |222    |
   3 |3  |Julie     |Roberts   |666    |
   4 |4  |Jane      |Seymore   |333    |
   5 |5  |Joe       |Smith     |555    |
   6 |6  |Bes       |Doe       |444    |
     |---------------------------------|

$ uprint -e output
     |---------------------------------------------------------------|
     |seq|   fname  |   lname  |  key  | REC | rec | recQ| recK| recM|
     | no|          |          |       |     |     |     |     |     |
     |---------------------------------------------------------------|
   1 |1  |Bob       |Jones     |111    |     |     |     |     |     |
   2 |2  |Jane      |Seymore   |333    |     |     |     |     |     |
     |---------------------------------------------------------------|

$ umerge -F2 all rec# as rec REC# as REC recQ# as recQ \e
> recK# as recK recM# as recM keyed by key from input in output keyed
umerge: 4 records merged - 6 total
$ uprint -e output
     |---------------------------------------------------------------|
     |seq|   fname  |   lname  |  key  | REC | rec | recQ| recK| recM|
     | no|          |          |       |     |     |     |     |     |
     |---------------------------------------------------------------|
   1 |1  |Bob       |Jones     |111    |     |     |     |     |     |
   2 |2  |John      |Doe       |222    |  02 |  2  |  1  |  1  |  1  |
   3 |2  |Jane      |Seymore   |333    |     |     |     |     |     |
   4 |6  |Bes       |Doe       |444    |  04 |  6  |  3  |  3  |  2  |
   5 |1  |Joe       |Smith     |555    |  05 |  1  |  4  |  4  |  3  |
   6 |3  |Julie     |Roberts   |666    |  06 |  3  |  6  |  5  |  4  |
     |---------------------------------------------------------------|
.ft
.fi
.RE
.PP
It should be noted in the example above that the value of ``recK''
skipped from a value of 1 (output table rec# 2) to a value of 3
(output table rec# 4) since the output table had an existing record
with the same key value as the input table.
In addition, the value of ``recQ'' skipped from a value of 4
(output table rec# 5) to a value of 6 (output table rec# 6)
since the input table had two records with the same key value.
.SH FILES
.so Files.u.h
.br
.ne 3
.SH "SEE ALSO"
descriptor(4), ninsert(1), retrieve(1), setunpackenv(3), and usort(1)
