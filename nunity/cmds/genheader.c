/******************************************************************************

                ###############################################
                # Copyright 2002-2003 Lucent Technologies Inc #
                #              All Rights Reserved            #
                ###############################################

******************************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <ctype.h>
#include "uquery.h"

extern char *getrelname();

static int
findaref( keyattr, attrptr, attrcnt )
register struct qprojection *keyattr;
register struct qprojection *attrptr;
register int attrcnt;
{
	register int i;

	for( i = 0; i < attrcnt; i++, attrptr++ )
	{
		if ( (attrptr->flags & QP_NODISPLAY) == 0 &&
			(( keyattr->rel == attrptr->rel &&
			keyattr->attr == attrptr->attr ) ||
			strcmp( keyattr->prname, attrptr->prname ) == 0 ) )
		{
			return( i );
		}
	}

	return( -1 );
}

int
genheader( qname, query, include_prefix )
char *qname;
struct uquery *query;
char *include_prefix;
{
	register char *str, *dest;
	register int i;
	int projcnt;
	char all_attr;
	struct qprojection *refptr;
	FILE *fp;
	char buf[MAXPATH+4];	/* allow for "/./" or "././" prefix */

	sprintf( buf, "%s.h", qname );
	if ( (fp = fopen( buf, "w" )) == NULL )
		return( FALSE );

	fputs( "/*\n * THIS IS A GENERATED HEADER FILE!!\n *\n * It is generated by the cmpquery command.\n */\n\n", fp );

	if ( include_prefix )
		fprintf( fp, "#include \"%s%suquery.h\"\n\n",
			include_prefix,
			*include_prefix ? "/" : "" );

	fprintf( fp, "\
/*\n\
 * Below is the query this file is corresponds to.\n\
 */\n\
extern struct uquery %s;\n\n",
		qname );

	/*
	 * Print the external definition for the query init function.
	 */
	fprintf( fp, "\
/*\n\
 * Below is the initialization function for the above query.  This\n\
 * function must be called once before the above query is passed\n\
 * to the queryeval() function.\n\
 *\n\
 * A pointer to each relation used in the query must be passed to\n\
 * this function.  The relations' file name and their relative\n\
 * ordering are shown below.  The relations MUST be passed in the\n\
 * correct order or query initialization will most likely fail.  Worse\n\
 * yet, if initialization does succeed, query evaluation will give\n\
 * the wrong results.\n\
 */\n\
extern int init%s(\n",
		qname );

	for( i = 0; i < query->nodecnt; i++ ) {
		fprintf( fp, "\t/* struct urelation *r%d_%s%s */\n",
			i + 1, getrelname( query->nodelist[i]->rel->path ),
			i != query->nodecnt - 1 ? "," : "" );
	}
	fputs( ");\n\n", fp );

	prexterns( fp, query->operlist );

	/*
	 * Now define the macros for the projected attributes.
	 */
	strcpy( buf, "#define " );
	dest = &buf[strlen( buf )];
	for( str = qname; *str; )
		*dest++ = toupper( *str++ );
	*dest++ = '_';
	*dest++ = '\0';

	fputs( "\n\
/*\n\
 * Below are definitions for the projected attributes of the query.\n\
 * They should be used to access the projected attributes symbolicly.\n\
 */\n",
		fp );
	all_attr = FALSE;
	projcnt = 0;
	for( i = 0, refptr = query->attrlist; i < query->attrcnt;
			i++, refptr++ ) {

		if ( refptr->flags & QP_NODISPLAY )
			continue;	/* non-projected attribute */

		if ( refptr->attr == ATTR_ALL ) {
			fputs( "\n/* \"all\" attribute is projected -- no more attribute numbers can be determined. */\n", fp );
			all_attr = TRUE;
			break;
		}

		if ( findaref( refptr, query->attrlist, i ) >= 0 )
			continue;	/* same attribute projected twice */

		fputs( buf, fp );
		str = refptr->prname;
		if ( ! isalpha( *str ) ) {
			putc( '_', fp );
			str++;
		}
		for( ; *str; str++ ) {
			putc( isalnum( *str ) ? toupper( *str ) : '_', fp );
		}
		fprintf( fp, "\t\t%d\n", projcnt++ );
	}

	fputs( "\n\
/*\n\
 * Below is a definition for the number of attributes projected\n\
 * in the query.  This can be used to allocate the proper number of\n\
 * character pointers in an array for each projected tuple returned\n\
 * by the query.\n",
		fp );
	if ( all_attr )
		fprintf( fp, "\
 *\n\
 * Since the \"all\" attribute is projected, the number of projected\n\
 * attributes is not known until run-time.  So, we need to allocate\n\
 * the maximum number of possible attributes.\n\
 */\n\
%sMAXATT\t\tMAXATT\n",
			buf );
	else
		fprintf( fp, " */\n%sMAXATT\t\t%d\n", buf, projcnt );

	return( TRUE );
}
